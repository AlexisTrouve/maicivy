package repositories

import (
	"context"
	"fmt"
	"time"

	"gorm.io/gorm"
)

// LettersRepository handles optimized database queries for generated letters
type LettersRepository struct {
	db *gorm.DB
}

// NewLettersRepository creates a new letters repository
func NewLettersRepository(db *gorm.DB) *LettersRepository {
	return &LettersRepository{db: db}
}

// GeneratedLetter represents the generated_letters table model
type GeneratedLetter struct {
	ID          uint      `gorm:"primaryKey" json:"id"`
	VisitorID   string    `json:"visitor_id"`
	CompanyName string    `json:"company_name"`
	LetterType  string    `json:"letter_type"` // "motivation" or "anti_motivation"
	Content     string    `json:"content"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

// CreateLetter creates a new generated letter
func (r *LettersRepository) CreateLetter(ctx context.Context, letter *GeneratedLetter) error {
	if err := r.db.WithContext(ctx).Create(letter).Error; err != nil {
		return fmt.Errorf("failed to create letter: %w", err)
	}
	return nil
}

// GetLetterByVisitorAndCompany retrieves a letter by visitor ID, company, and type
// Uses idx_letters_lookup composite index for fast lookup
func (r *LettersRepository) GetLetterByVisitorAndCompany(ctx context.Context, visitorID, companyName, letterType string) (*GeneratedLetter, error) {
	var letter GeneratedLetter

	// Uses composite index: idx_letters_lookup (visitor_id, company_name, letter_type)
	if err := r.db.WithContext(ctx).
		Where("visitor_id = ? AND company_name = ? AND letter_type = ?", visitorID, companyName, letterType).
		First(&letter).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil // Not found, not an error
		}
		return nil, fmt.Errorf("failed to fetch letter: %w", err)
	}

	return &letter, nil
}

// GetLettersByVisitor retrieves all letters generated by a specific visitor
// Uses idx_letters_visitor index
func (r *LettersRepository) GetLettersByVisitor(ctx context.Context, visitorID string, limit, offset int) ([]GeneratedLetter, error) {
	var letters []GeneratedLetter

	if err := r.db.WithContext(ctx).
		Where("visitor_id = ?", visitorID).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&letters).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch letters by visitor: %w", err)
	}

	return letters, nil
}

// GetLettersByCompany retrieves all letters generated for a specific company
// Uses idx_letters_company index
func (r *LettersRepository) GetLettersByCompany(ctx context.Context, companyName string, limit, offset int) ([]GeneratedLetter, error) {
	var letters []GeneratedLetter

	if err := r.db.WithContext(ctx).
		Where("company_name = ?", companyName).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&letters).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch letters by company: %w", err)
	}

	return letters, nil
}

// GetRecentLetters retrieves most recent letters
// Uses idx_letters_created_at index
func (r *LettersRepository) GetRecentLetters(ctx context.Context, limit int) ([]GeneratedLetter, error) {
	var letters []GeneratedLetter

	if err := r.db.WithContext(ctx).
		Order("created_at DESC").
		Limit(limit).
		Find(&letters).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch recent letters: %w", err)
	}

	return letters, nil
}

// CountLettersByVisitor counts total letters generated by a visitor
func (r *LettersRepository) CountLettersByVisitor(ctx context.Context, visitorID string) (int64, error) {
	var count int64

	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Where("visitor_id = ?", visitorID).
		Count(&count).Error; err != nil {
		return 0, fmt.Errorf("failed to count letters: %w", err)
	}

	return count, nil
}

// CountLettersByType counts letters by type (motivation vs anti-motivation)
func (r *LettersRepository) CountLettersByType(ctx context.Context, startDate, endDate time.Time) (map[string]int64, error) {
	type Result struct {
		LetterType string
		Count      int64
	}

	var results []Result

	// Uses idx_letters_date_type composite index
	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Select("letter_type, COUNT(*) as count").
		Where("created_at BETWEEN ? AND ?", startDate, endDate).
		Group("letter_type").
		Scan(&results).Error; err != nil {
		return nil, fmt.Errorf("failed to count letters by type: %w", err)
	}

	// Convert to map
	counts := make(map[string]int64)
	for _, r := range results {
		counts[r.LetterType] = r.Count
	}

	return counts, nil
}

// GetLettersStatsByDay retrieves daily letter generation statistics
func (r *LettersRepository) GetLettersStatsByDay(ctx context.Context, days int) ([]DailyStats, error) {
	var stats []DailyStats

	// Uses idx_letters_created_at index
	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Select("DATE(created_at) as date, letter_type, COUNT(*) as count").
		Where("created_at >= ?", time.Now().AddDate(0, 0, -days)).
		Group("DATE(created_at), letter_type").
		Order("date DESC").
		Scan(&stats).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch daily stats: %w", err)
	}

	return stats, nil
}

// DailyStats represents daily letter generation statistics
type DailyStats struct {
	Date       string `json:"date"`
	LetterType string `json:"letter_type"`
	Count      int64  `json:"count"`
}

// CheckDuplicate checks if a letter already exists for visitor + company + type
// Returns true if duplicate exists
func (r *LettersRepository) CheckDuplicate(ctx context.Context, visitorID, companyName, letterType string) (bool, error) {
	letter, err := r.GetLetterByVisitorAndCompany(ctx, visitorID, companyName, letterType)
	if err != nil {
		return false, err
	}
	return letter != nil, nil
}

// GetLetterByID retrieves a single letter by ID
func (r *LettersRepository) GetLetterByID(ctx context.Context, id uint) (*GeneratedLetter, error) {
	var letter GeneratedLetter

	if err := r.db.WithContext(ctx).
		First(&letter, id).Error; err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil
		}
		return nil, fmt.Errorf("failed to fetch letter: %w", err)
	}

	return &letter, nil
}

// DeleteLetter deletes a letter by ID
func (r *LettersRepository) DeleteLetter(ctx context.Context, id uint) error {
	if err := r.db.WithContext(ctx).
		Delete(&GeneratedLetter{}, id).Error; err != nil {
		return fmt.Errorf("failed to delete letter: %w", err)
	}
	return nil
}

// DeleteOldLetters deletes letters older than specified days
func (r *LettersRepository) DeleteOldLetters(ctx context.Context, olderThanDays int) (int64, error) {
	cutoffDate := time.Now().AddDate(0, 0, -olderThanDays)

	result := r.db.WithContext(ctx).
		Where("created_at < ?", cutoffDate).
		Delete(&GeneratedLetter{})

	if result.Error != nil {
		return 0, fmt.Errorf("failed to delete old letters: %w", result.Error)
	}

	return result.RowsAffected, nil
}

// GetTopCompanies retrieves most requested companies
func (r *LettersRepository) GetTopCompanies(ctx context.Context, limit int) ([]CompanyStats, error) {
	var stats []CompanyStats

	// Uses idx_letters_company index
	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Select("company_name, COUNT(*) as count").
		Group("company_name").
		Order("count DESC").
		Limit(limit).
		Scan(&stats).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch top companies: %w", err)
	}

	return stats, nil
}

// CompanyStats represents company letter generation statistics
type CompanyStats struct {
	CompanyName string `json:"company_name"`
	Count       int64  `json:"count"`
}

// GetTotalLettersCount returns total number of letters generated
func (r *LettersRepository) GetTotalLettersCount(ctx context.Context) (int64, error) {
	var count int64

	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Count(&count).Error; err != nil {
		return 0, fmt.Errorf("failed to count total letters: %w", err)
	}

	return count, nil
}

// GetLettersByDateRange retrieves letters within a date range
func (r *LettersRepository) GetLettersByDateRange(ctx context.Context, startDate, endDate time.Time, limit, offset int) ([]GeneratedLetter, error) {
	var letters []GeneratedLetter

	// Uses idx_letters_created_at index
	if err := r.db.WithContext(ctx).
		Where("created_at BETWEEN ? AND ?", startDate, endDate).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&letters).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch letters by date range: %w", err)
	}

	return letters, nil
}

// BulkInsertLetters inserts multiple letters efficiently
func (r *LettersRepository) BulkInsertLetters(ctx context.Context, letters []GeneratedLetter) error {
	batchSize := 100
	if err := r.db.WithContext(ctx).CreateInBatches(letters, batchSize).Error; err != nil {
		return fmt.Errorf("failed to bulk insert letters: %w", err)
	}
	return nil
}

// UpdateLetter updates a letter's content
func (r *LettersRepository) UpdateLetter(ctx context.Context, id uint, content string) error {
	if err := r.db.WithContext(ctx).
		Model(&GeneratedLetter{}).
		Where("id = ?", id).
		Update("content", content).Error; err != nil {
		return fmt.Errorf("failed to update letter: %w", err)
	}
	return nil
}
